---
apiVersion: batch/v1
kind: Job
metadata:
  name: istio
  namespace: istio-system
  labels:
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/instance: istio
    app.kubernetes.io/version: 1.0.0
    helm.sh/chart: helmsman-1.0.0
  annotations:
    helm.sh/hook: post-install
spec:
  template:
    metadata:
      name: istio
      namespace: istio-system
      labels:
        app.kubernetes.io/managed-by: Helm
        app.kubernetes.io/instance: istio
        helm.sh/chart: helmsman-1.0.0
        sidecar.istio.io/inject: "false"
    spec:
      serviceAccountName: istio-system
      restartPolicy: Never
      containers:
        - name: post-install-job
          image: bitnami/kubectl:1.26.8
          command:
            - /bin/bash
            - -c
            - >
              #!/bin/bash

              # Install ingress gateways


              #NOTE: istioctl is specific to kubeconfig file. If you've more than one config files, please specify them like mentioned below:

              #istioctl --kubeconfig <path-to-config-file> or use -c as shorthand for --kubeconfig.


              NS=istio-system


              echo Operator init

              istioctl operator init


              function installing_istio() {
                echo Create ingress gateways, load balancers and istio monitoring
                kubectl -n $NS apply -f ./utils/istio-mesh/nodeport/iop-mosip.yaml
                kubectl -n $NS apply -f ./utils/istio-mesh/nodeport/istio-monitoring/
                echo Wait for all resources to come up
                sleep 10
                kubectl -n $NS rollout status deploy istiod
                kubectl -n $NS rollout status deploy istio-ingressgateway
                kubectl -n $NS rollout status deploy istio-ingressgateway-internal

                echo ------ IMPORTANT ---------
                echo If you already have pods running with envoy sidecars, restart all of them NOW.  Check if all of them appear with command "istioctl proxy-status"
                echo --------------------------
                return 0
              }


              # set commands for error handling.

              set -e

              set -o errexit   ## set -e : exit the script if any statement returns a non-true return value

              set -o nounset   ## set -u : exit the script if you try to use an uninitialised variable

              set -o errtrace  # trace ERR through 'time command' and other functions

              set -o pipefail  # trace ERR through pipes

              installing_istio   # calling function

---
apiVersion: batch/v1
kind: Job
metadata:
  name: istio
  namespace: istio-system
  labels:
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/instance: istio
    app.kubernetes.io/version: 1.0.0
    helm.sh/chart: helmsman-1.0.0
  annotations:
    helm.sh/hook: post-install
spec:
  template:
    metadata:
      name: istio
      namespace: istio-system
      labels:
        app.kubernetes.io/managed-by: Helm
        app.kubernetes.io/instance: istio
        helm.sh/chart: helmsman-1.0.0
        sidecar.istio.io/inject: "false"
    spec:
      serviceAccountName: istio-system
      restartPolicy: Never
      containers:
        - name: post-install-job
          image: bitnami/kubectl:1.26.8
          command:
            - /bin/bash
            - -c
            - >
              #!/bin/bash

              # Install ingress gateways


              #NOTE: istioctl is specific to kubeconfig file. If you've more than one config files, please specify them like mentioned below:

              #istioctl --kubeconfig <path-to-config-file> or use -c as shorthand for --kubeconfig.


              if [ $# -ge 1 ] ; then
                export KUBECONFIG=$1
              fi


              function gateway() {


              NS=istio-system


              echo Installing gateways, proxy protocol, authpolicies

              PUBLIC=$(kubectl get cm global -o jsonpath={.data.mosip-api-host})

              INTERNAL=$(kubectl get cm global -o jsonpath={.data.mosip-api-internal-host})

              echo Public domain: $PUBLIC

              echo Internal dome: $INTERNAL



              ##helm -n istio-system install istio-addons chart/istio-addons --set gateway.public.host=$PUBLIC --set gateway.internal.host=$INTERNAL --set proxyProtocol.enabled=false


              # Check if the internal gateway exists

              internal_exists=$(kubectl get gateway internal -n istio-system --ignore-not-found=true)


              # Check if the public gateway exists

              public_exists=$(kubectl get gateway public -n istio-system --ignore-not-found=true)


              if [[ -n "$public_exists" && -z "$internal_exists" ]]; then
                echo "Public gateway is present, but internal is not."
                gateway_option="--set gateway.public.enabled=false --set gateway.internal.host=$INTERNAL"
              elif [[ -n "$internal_exists" && -z "$public_exists" ]]; then
                echo "Internal gateway is present, but public is not."
                gateway_option="--set gateway.public.host=$PUBLIC --set gateway.internal.enabled=false"
              elif [[ -z "$public_exists" && -z "$internal_exists" ]]; then
                echo "Neither public nor internal gateway is present."
                gateway_option="--set gateway.public.host=$PUBLIC --set gateway.internal.host=$INTERNAL"
              fi


              if [[ -n "$public_exists" && -n "$internal_exists" ]]; then
                echo "Both public and internal gateways exist. Skipping installation."
              else
                helm -n $NS install istio-addons . \
                  $gateway_option \
                  --set proxyProtocol.enabled=false \
                  --wait
              fi


              }


              # set commands for error handling.

              set -e

              set -o errexit   # exit the script if any statement returns a non-true return value

              set -o nounset   # exit the script if you try to use an uninitialised variable

              set -o errtrace  # trace ERR through 'time command' and other functions

              set -o pipefail  # trace ERR through pipes

              gateway

---
apiVersion: batch/v1
kind: Job
metadata:
  name: httpbin
  namespace: httpbin
  labels:
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/instance: httpbin
    app.kubernetes.io/version: 1.0.0
    helm.sh/chart: helmsman-1.0.0
  annotations:
    helm.sh/hook: post-install
spec:
  template:
    metadata:
      name: httpbin
      namespace: httpbin
      labels:
        app.kubernetes.io/managed-by: Helm
        app.kubernetes.io/instance: httpbin
        helm.sh/chart: helmsman-1.0.0
        sidecar.istio.io/inject: "false"
    spec:
      serviceAccountName: httpbin
      restartPolicy: Never
      containers:
        - name: post-install-job
          image: bitnami/kubectl:1.26.8
          command:
            - /bin/bash
            - -c
            - >
              #!/bin/bash

              ## Usage: ./install.sh [kubeconfig]


              if [ $# -ge 1 ] ; then
                export KUBECONFIG=$1
              fi


              NS=httpbin

              kubectl create ns $NS


              function installing_httpbin() {
                kubectl label ns $NS istio-injection=enabled --overwrite

                kubectl -n $NS apply -f ./utils/httpbin/svc.yaml
                kubectl -n $NS apply -f ./utils/httpbin/deployment.yaml
                kubectl -n $NS apply -f ./utils/httpbin/deployment-busybox-curl.yaml
                kubectl -n $NS apply -f ./utils/httpbin/vs.yaml
                return 0
              }


              # set commands for error handling.

              set -e

              set -o errexit   ## set -e : exit the script if any statement returns a non-true return value

              set -o nounset   ## set -u : exit the script if you try to use an uninitialised variable

              set -o errtrace  # trace ERR through 'time command' and other functions

              set -o pipefail  # trace ERR through pipes

              installing_httpbin  # calling function
